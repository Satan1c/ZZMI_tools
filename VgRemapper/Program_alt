using System.Collections.Frozen;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Text;
using System.Text.RegularExpressions;

Directory.SetCurrentDirectory("/Users/oleksandr.fedotov/Downloads/BelleSummerSkinMod/");
var inis = Directory
	.EnumerateFiles(Directory.GetCurrentDirectory(), "*.ini")
	.Select(x => new FileInfo(x))
	.ToArray();

var startTime = Stopwatch.GetTimestamp();
var linesTasks = new Task<(string lines, string[] separateLines)>[inis.Length];
for (var i = 0; i < inis.Length; i++) linesTasks[i] = GetIniLines(inis[i]);
await Task.WhenAll(linesTasks);

var lines = linesTasks
	.Select(t => t.Result)
	.ToArray();
linesTasks = null;

Console.WriteLine($"Lines parsed in {Stopwatch.GetElapsedTime(startTime)}");

startTime = Stopwatch.GetTimestamp();
var resourceNames = new ReadOnlyDictionary<string, string[]>[lines.Length];
for (var i = 0; i < lines.Length; i++) resourceNames[i] = GetResourceNames(lines[i].separateLines);

Console.WriteLine($"Resource names extracted in {Stopwatch.GetElapsedTime(startTime)}");

startTime = Stopwatch.GetTimestamp();
var resourceFiles = new ReadOnlyDictionary<string, FileInfo[]>[resourceNames.Length];
for (var i = 0; i < resourceNames.Length; i++) resourceFiles[i] = GetResourceFiles(resourceNames[i], lines[i].lines);

Console.WriteLine($"Resource files mapped in {Stopwatch.GetElapsedTime(startTime)}");

startTime = Stopwatch.GetTimestamp();
foreach (var (hash, files) in resourceFiles
	         .SelectMany(x => x.Select(y => (y.Key, y.Value))))
{
	// Run remaps in parallel, dedupe files referenced by multiple INIs
	var tasks = new List<Task>(files.Length);
	var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
	tasks.AddRange(from file in files where seen.Add(file.FullName) select Task.Run(() => Remap(hash, file)));
	await Task.WhenAll(tasks);
}

Console.WriteLine($"Remaps completed in {Stopwatch.GetElapsedTime(startTime)}");

public static partial class Program
{
	private const byte Stride = 32;

	private static readonly FrozenDictionary<string, (Index[] oldIndexes, Index[] newIndexes)> s_blendMappings =
		new Dictionary<string, (Index[] oldIndexes, Index[] newIndexes)>
		{
			{
				"4f3ddd5c",
				(
					[9, 10],
					[10, 9]
				)
			},
			{
				"0139f7e8",
				(
					[5, 6, 9, 10, 11, 12, 13, 14, 15],
					[9, 5, 10, 11, 12, 13, 14, 15, 6]
				)
			}
		}.ToFrozenDictionary();

	private static readonly FrozenDictionary<string, string> s_positionToBlend =
		new Dictionary<string, string>
		{
			{ "537d9b9b", "4f3ddd5c" },
			{ "324d9d21", "0139f7e8" }
		}.ToFrozenDictionary();

	private static readonly Regex s_hashRegex = MyRegex();
	private static readonly Regex s_blendResourceNameRegex = MyRegex1();
	private static readonly Regex s_blendResourceRegex = MyRegex2();

	[GeneratedRegex(@"^[ \t]*hash\s*=\s*(?<Hash>\w{8})",
		RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.Compiled)]
	private static partial Regex MyRegex();

	[GeneratedRegex(@"^[ \t]*vb2\s*=\s*(?:Resource(?<Name>.*))",
		RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.Compiled)]
	private static partial Regex MyRegex1();

	[GeneratedRegex(
		@"^[ \t]*\[Resource(?<Name>.*)\]$\s^[ \t]*type\s*=\s*Buffer$\s^[ \t]*stride\s*=\s*32$\s^[ \t]*filename\s*=\s*(?<File>.+)$",
		RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.Compiled)]
	private static partial Regex MyRegex2();

	private static async Task<(string lines, string[] separateLines)> GetIniLines(FileInfo file)
	{
		await using var readStream = file.OpenRead();
		using var reader = new StreamReader(readStream, leaveOpen: false);
		var lines = await reader.ReadToEndAsync();
		return (lines, lines.Split(Environment.NewLine));
	}

	private static ReadOnlyDictionary<string, string[]> GetResourceNames(string[] lines)
	{
		var resourceNamesMap = new Dictionary<string, string[]>();

		for (var i = 0; i < lines.Length; i++)
		{
			var line = lines[i];
			var hashMatch = s_hashRegex.Match(line);
			if (!hashMatch.Success) continue;

			var hash = hashMatch.Groups["Hash"].Value;
			if (!s_blendMappings.ContainsKey(hash) && !s_positionToBlend.TryGetValue(hash, out hash)) continue;
			if (line.TrimStart().StartsWith('[')) continue;

			var resourceNames = new LinkedList<string>();
			for (var j = i + 1; j < lines.Length; j++)
			{
				var nextLine = lines[j];
				if (nextLine.TrimStart().StartsWith('[')) break;
				var bledResourceNameMatch = s_blendResourceNameRegex.Match(nextLine);
				if (!bledResourceNameMatch.Success) continue;
				resourceNames.AddLast(bledResourceNameMatch.Groups["Name"].Value);
				break;
			}

			resourceNamesMap[hash] = resourceNames.ToArray();
		}

		return new ReadOnlyDictionary<string, string[]>(resourceNamesMap);
	}

	private static ReadOnlyDictionary<string, FileInfo[]> GetResourceFiles(
		IReadOnlyDictionary<string, string[]> namesMap, string lines)
	{
		// Precompute Resource(Name) -> [FileInfos] once per INI
		var nameToFiles = new Dictionary<string, List<FileInfo>>(StringComparer.Ordinal);
		foreach (Match match in s_blendResourceRegex.Matches(lines))
		{
			var name = match.Groups["Name"].Value;
			var path = Path.Combine(Directory.GetCurrentDirectory(), match.Groups["File"].Value);
			var fi = new FileInfo(path);
			if (!fi.Exists) continue;

			if (!nameToFiles.TryGetValue(name, out var list))
			{
				list = new List<FileInfo>(1);
				nameToFiles[name] = list;
			}
			list.Add(fi);
		}

		var resourceFilesMap = new Dictionary<string, FileInfo[]>();
		foreach (var (hash, names) in namesMap)
		{
			// Merge and dedupe by full path per hash
			var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			var list = new List<FileInfo>(names.Length);
			foreach (var name in names)
			{
				if (!nameToFiles.TryGetValue(name, out var files)) continue;
				list.AddRange(files.Where(fi => seen.Add(fi.FullName)));
			}
			resourceFilesMap[hash] = list.ToArray();
		}
		return new ReadOnlyDictionary<string, FileInfo[]>(resourceFilesMap);
	}

	private static byte[][] ReadBuffer(FileInfo file)
	{
		using var readStream = file.OpenRead();
		using var reader = new BinaryReader(readStream, Encoding.ASCII, false);
		var buffer = new byte[file.Length / Stride][];
		for (var i = 0; i < buffer.Length; i++) buffer[i] = reader.ReadBytes(Stride);

		return buffer;
	}

	private static void Remap(string hash, FileInfo file)
	{
		if (file.Length % Stride != 0)
			throw new InvalidDataException($"File size is not a multiple of the {Stride}-byte stride.");

		var (oldIndexes, newIndexes) = s_blendMappings[hash];

		var rowCount = checked((int)(file.Length / Stride));
		// Validate indices
		for (var i = 0; i < newIndexes.Length; i++)
		{
			var srcRow = oldIndexes[i].GetOffset(rowCount);
			var dstRow = newIndexes[i].GetOffset(rowCount);
			if ((uint)srcRow >= (uint)rowCount || (uint)dstRow >= (uint)rowCount)
				throw new IndexOutOfRangeException($"Remap index out of range: src={srcRow}, dst={dstRow}, rows={rowCount}");
		}

		// Read entire file once
		var src = File.ReadAllBytes(file.FullName);
		var dest = new byte[src.Length];
		Buffer.BlockCopy(src, 0, dest, 0, src.Length);

		for (var i = 0; i < newIndexes.Length; i++)
		{
			var srcRow = oldIndexes[i].GetOffset(rowCount);
			var dstRow = newIndexes[i].GetOffset(rowCount);
			if (srcRow == dstRow) continue;

			var srcSlice = src.AsSpan(srcRow * Stride, Stride);
			var dstSlice = dest.AsSpan(dstRow * Stride, Stride);
			srcSlice.CopyTo(dstSlice);
		}

		// Backup and write updated file
		var backupPath = Path.Combine(file.Directory!.FullName,
			$"{file.Name}_remap_backup_{DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()}");
		File.Copy(file.FullName, backupPath);

		File.WriteAllBytes(file.FullName, dest);
	}
}